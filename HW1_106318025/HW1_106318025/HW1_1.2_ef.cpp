/************************************************************/
/*  程式名稱：隨機等分圖像    	    						*/
/*  作者姓名：卓諭                                           */
/*	    學號:106318025                                      */
/*  指導教授：Dr.黃正民                                       */
/*  電子郵件：t106318025@ntut.org.tw                          */
/*                                                           */
/*  問題描述：這個程式將輸入的.raw檔灰階圖像做16等分切割         */
/*           並將16等分隨機換位，將最後的圖像資訊顯示並存成.raw檔*/
/*                                                           */
/*  輸入檔案：lena256.raw					                 */
/*  輸出檔案：利用imshow顯示一個二維矩陣(灰階圖像)              */
/*  需求項目：無                                             */
/************************************************************/
#include <cstdio>
#include <stdio.h>      // printf(), NULL 
#include <stdlib.h>     // srand(), rand() 
#include<time.h>
#include <opencv2/opencv.hpp>

using namespace cv;

int main()
{
	int col = 256;//設定要行向量要掃描幾個pixel
	int row = 256;//設定要列向量要掃描幾個pixel
	int i, j;//大小為0~3,為圖片切割成4*4矩陣的列向量及行向量
	int p, q;//隨機取大小0~3的值,為圖片切割成4*4矩陣的列向量及行向量
	int a, b;//大小為0~63,為了16格中一小格的掃瞄迴圈
	FILE *filein;//利用C++函示庫宣告一個filein以存放開啟檔案後的位址
	Mat figure_1(256, 256, CV_8UC1, Scalar(0));//利用OpenCV函示庫宣告一個256*256的矩陣空間
	Mat figure_2(256, 256, CV_8UC1, Scalar(0));
	/*-----------------------------------------------------開啟.raw檔---------------------------------------------------------------*/
	filein = fopen("lena256.raw", "rb");
	for (j = 0; j < row; j++)
	{
		for (i = 0; i < col; i++)
		{
			figure_1.data[i + j*row] = fgetc(filein);
		}
	}
	/*-----------------------------------------------------------------------------------------------------------------------------*/
	/*----------------------------------------------將原圖分成16等分並作隨機且不重複換位-----------------------------------------------*/
	srand(time(NULL)); //改變亂數種子，讓亂數不會每次都一樣
	for (j = 0; j < 4; j++)
	{
		for (i = 0; i < 4; i++)
		{
			
			p = rand() % 4;
			q = rand() % 4;
			while (1)
			{
				if (figure_1.data[64 * p + 256 * q * 64] == NULL)//若此像素有被更新為NULL代表該等分已被選過，則重新取一次亂數選其他等分
				{
					p = rand() % 4;//隨機取大小0~3的值,為圖片切割成4*4矩陣的列向量
					q = rand() % 4;//隨機取大小0~3的值,為圖片切割成4*4矩陣的行向量
				}
				else//若此像素沒有被更新為NULL代表是沒有選過的一格
					break;
			}
			for (a = 0; a < 64; a++)
			{
				for (b = 0; b < 64; b++)
				{
					figure_2.data[64 * i + 256 * j* 64 + b + 256 * a] = figure_1.data[64 * p + 256 * q * 64 + b + 256 * a];
				}
			}
			figure_1.data[64 * p + 256 * q * 64]=NULL;//將該等分第一個像素更新為NULL，代表以被選過了避免重複
		}
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/
	/*----------------------------------------------------------顯示random的圖-------------------------------------------------------*/
	imshow("randim", figure_2);
	waitKey(0);
	/*------------------------------------------------------------------------------------------------------------------------------*/
	/*-----------------------------------------------------------儲存成.raw檔--------------------------------------------------------*/
	FILE *save;
	save = fopen("output_random.raw", "w+b");
	fwrite(figure_2.data, 1, 65536, save);
	fclose(save);
	/*------------------------------------------------------------------------------------------------------------------------------*/
}